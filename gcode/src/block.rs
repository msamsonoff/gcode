use core::fmt::Debug;

use crate::decimal;
use crate::decimal::{Decimal, DecimalParser};
use crate::significand::Significand;

#[cfg(feature = "defmt")]
use defmt::Format;

/// The trait for types that can receive events from the [`BlockParser`].
pub trait BlockBuilder {
    /// The type of errors generated by the [`BlockBuilder`] itself.
    type Error;

    /// The type used as the significand for [`Decimal`] numbers.
    type Significand: Significand;

    /// Called for the program start character.
    fn program_start(&mut self) -> Result<(), Self::Error>;

    /// Called for a sequence number.
    fn sequence_number(
        &mut self,
        alignment: bool,
        number: Decimal<Self::Significand>,
    ) -> Result<(), Self::Error>;

    /// Called for a G code.
    fn g_code(&mut self, number: Decimal<Self::Significand>) -> Result<(), Self::Error>;

    /// Called for an M code.
    fn m_code(&mut self, number: Decimal<Self::Significand>) -> Result<(), Self::Error>;

    /// Called for a data word.
    fn data(
        &mut self,
        address: char,
        index: Option<Self::Significand>,
        number: Decimal<Self::Significand>,
    ) -> Result<(), Self::Error>;

    /// Called at the end of a block.
    fn end_block(&mut self) -> Result<(), Self::Error>;
}

/// The G-code parser.
#[derive(Debug)]
#[cfg_attr(feature = "defmt", derive(Format))]
pub struct BlockParser<S>
where
    S: Significand,
{
    control_out: bool,
    state: State<S>,
    decimal_parser: DecimalParser<S>,
}

impl<S> Default for BlockParser<S>
where
    S: Significand,
{
    fn default() -> Self {
        Self {
            control_out: false,
            state: State::Start,
            decimal_parser: DecimalParser::default(),
        }
    }
}

impl<S> BlockParser<S>
where
    S: Significand,
{
    /// Try to feed a string to the `BlockParser`.
    #[inline(never)]
    pub fn try_feed_str<T, B>(&mut self, s: T, builder: &mut B) -> Result<(), Error<B::Error>>
    where
        T: AsRef<str>,
        B: BlockBuilder<Significand = S>,
    {
        let s = s.as_ref();
        for c in s.chars() {
            self.try_feed_char(c, builder)?;
        }
        Ok(())
    }

    /// Try to feed a single character to the `BlockParser`.
    pub fn try_feed_char<B>(&mut self, c: char, builder: &mut B) -> Result<(), Error<B::Error>>
    where
        B: BlockBuilder<Significand = S>,
    {
        if '(' == c {
            self.control_out = true;
        } else if self.control_out {
            self.control_out = ')' != c;
        } else if '\n' == c {
            self.try_end(builder)?;
        } else if !Self::is_whitespace(c) {
            match self.state {
                State::Start => match c {
                    '%' => {
                        builder
                            .program_start()
                            .map_err(Error::new_block_builder_error)?;
                    }
                    '/' => {
                        self.state = State::BlockSkip;
                    }
                    ':' | 'N' | 'n' => {
                        let alignment = ':' == c;
                        self.state = State::Decimal(DecimalState::SequenceNumber { alignment });
                        self.decimal_parser = DecimalParser::default();
                    }
                    c => {
                        self.start_word::<B>(c)?;
                    }
                },
                State::BlockSkip => {
                    // do nothing
                }
                State::Index { address } => match c {
                    '0'..='9' => {
                        self.decimal_parser.try_feed(c)?;
                    }
                    '=' => {
                        let index = self.decimal_parser.try_end()?;
                        assert_eq!(index.negative_exponent(), 0);
                        let index = index.significand();
                        self.state = State::Decimal(DecimalState::IndexedWord { address, index });
                        self.decimal_parser = DecimalParser::default();
                    }
                    c => {
                        let decimal_state = DecimalState::Word { address };
                        self.state = State::Decimal(decimal_state);
                        self.parse_decimal(decimal_state, c, builder)?;
                    }
                },
                State::Decimal(decimal_state) => {
                    self.parse_decimal(decimal_state, c, builder)?;
                }
            };
        };
        Ok(())
    }

    /// Try to end the [`BlockParser`] (for example, at the end of a G-code file.)
    pub fn try_end<B>(&mut self, builder: &mut B) -> Result<(), Error<B::Error>>
    where
        B: BlockBuilder<Significand = S>,
    {
        match self.state {
            State::Start | State::BlockSkip => {
                self.state = State::Start;
                return Ok(()); // Return early to avoid endling a block that never started.
            }
            State::Index { address } => {
                let decimal_state = DecimalState::Word { address };
                self.state = State::Decimal(decimal_state);
                self.end_decimal(decimal_state, builder)?;
            }
            State::Decimal(decimal_state) => {
                self.end_decimal(decimal_state, builder)?;
            }
        };
        self.state = State::Start;
        builder
            .end_block()
            .map_err(Error::new_block_builder_error)?;
        Ok(())
    }

    const fn is_whitespace(c: char) -> bool {
        matches!(c, ' ' | '\t' | '\r')
    }

    fn start_word<B>(&mut self, address: char) -> Result<(), Error<B::Error>>
    where
        B: BlockBuilder<Significand = S>,
    {
        match address {
            'G' | 'M' | 'g' | 'm' => {
                self.state = State::Decimal(DecimalState::Word { address });
                self.decimal_parser = DecimalParser::default();
                Ok(())
            }
            'A'..='Z' | 'a'..='z' => {
                self.state = State::Index { address };
                self.decimal_parser = DecimalParser::default();
                Ok(())
            }
            _ => Err(Error::new_invalid_character()),
        }
    }

    fn parse_decimal<B>(
        &mut self,
        decimal_state: DecimalState<S>,
        c: char,
        builder: &mut B,
    ) -> Result<(), Error<B::Error>>
    where
        B: BlockBuilder<Significand = S>,
    {
        if let Err(e) = self.decimal_parser.try_feed(c) {
            match e {
                decimal::Error::InvalidCharacter => {
                    self.end_decimal(decimal_state, builder)?;
                    self.start_word::<B>(c)?;
                }
                _ => {
                    return Err(e.into());
                }
            }
        };
        Ok(())
    }

    fn end_decimal<B>(
        &mut self,
        decimal_state: DecimalState<S>,
        builder: &mut B,
    ) -> Result<(), Error<B::Error>>
    where
        B: BlockBuilder<Significand = S>,
    {
        let number = self.decimal_parser.try_end()?;
        let result = match decimal_state {
            DecimalState::SequenceNumber { alignment } => {
                builder.sequence_number(alignment, number)
            }
            DecimalState::IndexedWord { address, index } => {
                builder.data(address, Some(index), number)
            }
            DecimalState::Word { address } => Self::end_word(address, number, builder),
        };
        result.map_err(Error::new_block_builder_error)
    }

    fn end_word<B>(address: char, number: Decimal<S>, builder: &mut B) -> Result<(), B::Error>
    where
        B: BlockBuilder<Significand = S>,
    {
        match address {
            'G' | 'g' => builder.g_code(number),
            'M' | 'm' => builder.m_code(number),
            address => builder.data(address, None, number),
        }
    }
}

/// The categories of [`BlockParser`] errors.
#[derive(Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(Format))]
pub enum ErrorKind<E> {
    /// The [`BlockBuilder`] produced an error.
    BlockBuilderError(E),

    /// A numeric value exceeded the bounds of the [`Significand`] numeric type.
    Capacity,

    /// The [`BlockParser`] encountered an incomplete word, index, or number.
    Incomplete,

    /// The [`BlockParser`] encountered an invalid character.
    InvalidCharacter,
}

impl<E> Eq for ErrorKind<E> where E: Eq {}

/// The error type for the [`BlockParser`].
#[derive(Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(Format))]
pub struct Error<E> {
    kind: ErrorKind<E>,
}

impl<E> Eq for Error<E> where E: Eq {}

impl<E> From<decimal::Error> for Error<E> {
    fn from(value: decimal::Error) -> Self {
        match value {
            decimal::Error::Capacity => Self::new_capacity(),
            decimal::Error::Incomplete => Self::new_incomplete(),
            decimal::Error::InvalidCharacter => Self::new_invalid_character(),
        }
    }
}

impl<E> Error<E> {
    const fn new_block_builder_error(error: E) -> Self {
        Self {
            kind: ErrorKind::BlockBuilderError(error),
        }
    }

    const fn new_capacity() -> Self {
        Self {
            kind: ErrorKind::Capacity,
        }
    }

    const fn new_incomplete() -> Self {
        Self {
            kind: ErrorKind::Incomplete,
        }
    }

    const fn new_invalid_character() -> Self {
        Self {
            kind: ErrorKind::InvalidCharacter,
        }
    }

    /// Returns the [`ErrorKind`] of the error.
    pub const fn kind(&self) -> &ErrorKind<E> {
        &self.kind
    }
}

#[derive(Clone, Copy, Debug)]
#[cfg_attr(feature = "defmt", derive(Format))]
enum State<S>
where
    S: Significand,
{
    Start,
    BlockSkip,
    Index { address: char },
    Decimal(DecimalState<S>),
}

#[derive(Clone, Copy, Debug)]
#[cfg_attr(feature = "defmt", derive(Format))]
enum DecimalState<S>
where
    S: Significand,
{
    SequenceNumber { alignment: bool },
    IndexedWord { address: char, index: S },
    Word { address: char },
}

#[cfg(test)]
mod tests {
    extern crate std;

    use std::vec;
    use std::vec::Vec;

    use super::*;

    #[derive(Debug, Eq, PartialEq)]
    enum Item {
        Start,
        SequenceNumber {
            alignment: bool,
            number: Decimal<i32>,
        },
        GCode {
            number: Decimal<i32>,
        },
        MCode {
            number: Decimal<i32>,
        },
        Data {
            address: char,
            index: Option<i32>,
            number: Decimal<i32>,
        },
        End,
    }

    impl BlockBuilder for Vec<Item> {
        type Error = ();
        type Significand = i32;

        fn program_start(&mut self) -> Result<(), Self::Error> {
            self.push(Item::Start);
            Ok(())
        }

        fn sequence_number(
            &mut self,
            alignment: bool,
            number: Decimal<i32>,
        ) -> Result<(), Self::Error> {
            self.push(Item::SequenceNumber { alignment, number });
            Ok(())
        }

        fn g_code(&mut self, number: Decimal<i32>) -> Result<(), Self::Error> {
            self.push(Item::GCode { number });
            Ok(())
        }

        fn m_code(&mut self, number: Decimal<i32>) -> Result<(), Self::Error> {
            self.push(Item::MCode { number });
            Ok(())
        }

        fn data(
            &mut self,
            address: char,
            index: Option<i32>,
            number: Decimal<i32>,
        ) -> Result<(), Self::Error> {
            self.push(Item::Data {
                address,
                index,
                number,
            });
            Ok(())
        }

        fn end_block(&mut self) -> Result<(), Self::Error> {
            self.push(Item::End);
            Ok(())
        }
    }

    //
    // BlockParser
    //

    #[test]
    fn comprehensive() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser
            .try_feed_str(
                "% : 1 G 2 X 3 . 4 Y 5 = 6 \n M 7 . 8 \n / Z 9 \n G 1 0 ( . 1 1 ) 1 2 \n U 1 3 \n",
                &mut vec,
            )
            .unwrap();
        block_parser.try_end(&mut vec).unwrap();
        assert_eq!(
            vec,
            vec![
                Item::Start,
                Item::SequenceNumber {
                    alignment: true,
                    number: Decimal::new(1, 0),
                },
                Item::GCode {
                    number: Decimal::new(2, 0),
                },
                Item::Data {
                    address: 'X',
                    index: None,
                    number: Decimal::new(34, 1),
                },
                Item::Data {
                    address: 'Y',
                    index: Some(5),
                    number: Decimal::new(6, 0),
                },
                Item::End,
                Item::MCode {
                    number: Decimal::new(78, 1),
                },
                Item::End,
                Item::GCode {
                    number: Decimal::new(1012, 0),
                },
                Item::End,
                Item::Data {
                    address: 'U',
                    index: None,
                    number: Decimal::new(13, 0),
                },
                Item::End,
            ]
        );
    }

    //
    // BlockParser, state = Start
    //

    #[test]
    fn block_parser_start() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser.try_feed_char('%', &mut vec).unwrap();
        assert_eq!(vec, vec![Item::Start]);
    }

    #[test]
    fn block_parser_start_try_end() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser.try_end(&mut vec).unwrap();
        assert_eq!(vec, vec![]);
    }

    //
    // BlockParser, state = BlockSkip
    //

    #[test]
    fn block_parser_block_skip() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser
            .try_feed_str("G1\n/G2\nG3\n", &mut vec)
            .unwrap();
        block_parser.try_end(&mut vec).unwrap();
        assert_eq!(
            vec,
            vec![
                Item::GCode {
                    number: Decimal::new(1, 0)
                },
                Item::End,
                Item::GCode {
                    number: Decimal::new(3, 0)
                },
                Item::End,
            ],
        );
    }

    #[test]
    fn block_parser_block_skip_try_end() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser.try_feed_str("/P3", &mut vec).unwrap();
        block_parser.try_end(&mut vec).unwrap();
        assert_eq!(vec, vec![]);
    }

    //
    // BlockPaser, state = Index
    //

    #[test]
    fn block_parser_index_try_end() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser.try_feed_str("Y7", &mut vec).unwrap();
        block_parser.try_end(&mut vec).unwrap();
        assert_eq!(
            vec,
            vec![
                Item::Data {
                    address: 'Y',
                    index: None,
                    number: Decimal::new(7, 0),
                },
                Item::End
            ]
        );
    }

    #[test]
    fn block_parser_index_capacity() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        let result = block_parser.try_feed_str("J2147483648", &mut vec);
        assert_eq!(result, Err(Error::new_capacity()));
        assert_eq!(vec, vec![]);
    }

    #[test]
    fn block_parser_index_incomplete() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser.try_feed_str("V", &mut vec).unwrap();
        let result = block_parser.try_end(&mut vec);
        assert_eq!(result, Err(Error::new_incomplete()));
        assert_eq!(vec, vec![]);
    }

    #[test]
    fn block_parser_index_invalid_character() {
        // There's no way to get an InvalidCharacter from the Index state. It's either Incomplete
        // as in the previous test or the parser transitions to the Decimal state and generates an
        // Incomplete from there instead.
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        let result = block_parser.try_feed_str("Q,", &mut vec);
        assert_eq!(result, Err(Error::new_incomplete()));
        assert_eq!(vec, vec![]);
    }

    //
    // BlockParser, state = Decimal
    //

    #[test]
    fn block_parser_decimal_capacity() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        let result = block_parser.try_feed_str("S3=2147483648", &mut vec);
        assert_eq!(result, Err(Error::new_capacity()));
        assert_eq!(vec, vec![]);
    }

    #[test]
    fn block_parser_decimal_incomplete() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser.try_feed_str("I2=.", &mut vec).unwrap();
        let result = block_parser.try_end(&mut vec);
        assert_eq!(result, Err(Error::new_incomplete()));
        assert_eq!(vec, vec![]);
    }

    #[test]
    fn block_parser_decimal_invalid_character() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        let result = block_parser.try_feed_str("T6=5+", &mut vec);
        assert_eq!(result, Err(Error::new_invalid_character()));
        assert_eq!(
            vec,
            vec![Item::Data {
                address: 'T',
                index: Some(6),
                number: Decimal::new(5, 0),
            },]
        );
    }

    //
    // BlockParser, state = Decimal(SequenceNumber)
    //

    #[test]
    fn block_parser_sequence_number_try_end() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser.try_feed_str("N3", &mut vec).unwrap();
        block_parser.try_end(&mut vec).unwrap();
        assert_eq!(
            vec,
            vec![
                Item::SequenceNumber {
                    alignment: false,
                    number: Decimal::new(3, 0),
                },
                Item::End
            ]
        );
    }

    //
    // BlockParser, state = Decimal(IndexedWord)
    //

    #[test]
    fn block_parser_indexed_word_try_end() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser.try_feed_str("Q8=3", &mut vec).unwrap();
        block_parser.try_end(&mut vec).unwrap();
        assert_eq!(
            vec,
            vec![
                Item::Data {
                    address: 'Q',
                    index: Some(8),
                    number: Decimal::new(3, 0),
                },
                Item::End
            ]
        );
    }

    //
    // BlockParser, state = Decimal(Word)
    //

    #[test]
    fn block_parser_word_try_end() {
        let mut block_parser: BlockParser<i32> = BlockParser::default();
        let mut vec = Vec::new();
        block_parser.try_feed_str("D9", &mut vec).unwrap();
        block_parser.try_end(&mut vec).unwrap();
        assert_eq!(
            vec,
            vec![
                Item::Data {
                    address: 'D',
                    index: None,
                    number: Decimal::new(9, 0),
                },
                Item::End
            ]
        );
    }

    //
    // ErrorKind
    //

    #[test]
    fn error_kind_eq_block_builder_error() {
        assert_eq!(
            ErrorKind::BlockBuilderError(()),
            ErrorKind::BlockBuilderError(())
        );
    }

    #[test]
    fn error_kind_eq_block_builder_error_false() {
        assert_ne!(
            ErrorKind::BlockBuilderError(6),
            ErrorKind::BlockBuilderError(8)
        );
    }

    #[test]
    fn error_kind_eq_false() {
        assert_ne!(ErrorKind::<()>::Capacity, ErrorKind::<()>::Incomplete);
    }

    //
    // Error
    //

    #[test]
    fn error_new_block_builder_error() {
        let error: Error<()> = Error::new_block_builder_error(());
        assert_eq!(error, Error::new_block_builder_error(()));
    }

    #[test]
    fn error_from_capacity() {
        let error: Error<()> = decimal::Error::Capacity.into();
        assert_eq!(error, Error::new_capacity());
    }

    #[test]
    fn error_from_incomplete() {
        let error: Error<()> = decimal::Error::Incomplete.into();
        assert_eq!(error, Error::new_incomplete());
    }

    #[test]
    fn error_from_invalid_character() {
        let error: Error<()> = decimal::Error::InvalidCharacter.into();
        assert_eq!(error, Error::new_invalid_character());
    }
}
